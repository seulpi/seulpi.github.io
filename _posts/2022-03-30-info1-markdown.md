---
    layout: post
    title: 1.요구사항 확인
    subtitle: ★★★ 
    categories: markdown
    tags: [정보처리기사_실기]
---

# ★★★ 1. 요구사항확인 ★★★
## 1-1. 소프트웨어 개발론
### * 소프트웨어 생명주기(Software Development Life Cycle) 
- 정의 : 시스템의 "요구분석~유지보수" 과정을 체계화한 절차 (작업 프로세스에 대한 모델화)
- 순서 : (분석구테유) <br> 
    - 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수 
- 종류 : (폭프나반 : 전통적 방법론 -> 애자일 방법론과 대비) <br>
    1. 폭포수 모델(Waterfall Model) 
        - 소프트웨어 개발 시 각 단계를 "확실히 마무리 지은 후" 다음 단계로 넘어가는 모델 (스텝바이스텝)
         <br> -> 단계 별 정의와 산출물이 명확 <br> -> but 요구 사항 변경이 어렵다
        - 가장 "오래된 모델" 로 적용 경험 + 성공 사례 多
        - 고전적 생명주기 모형
        - 이해가 용이, 관리가 편함, 요구사항 변경이 어려움
        - >> [절차] 타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수
    <br>
    2. 프로토타이핑 모델(Prototyping Model) 
        - 고객이 '요구한 주요 기능을 프로토타입으로 구현'해 고객의 '피드백을 반영하여' 소프트웨어를 만들어가는 모델 
        - 고객이나 개발자에게 '공동의 참조모델을 제공'
        - 프로토타입은 구현 단계의 구현 골격
        - 요구분석 용이, 타당성 검증 가능, 프로토타입 폐기에 따른 비용↑
    <br>
    3. 나선형 모델(Spriral Model) 
        - **위험을 최소화**하기 위해 **점진적으로** .. 완벽한 시스템으로 개발해나가는 모델
        - >>[절차] 계획 및 정의 → 위험 분석 → 개발 → 고객 평가
     - 위험성 ↓, 변경에 유연한 대처 가능 , 관리가 어려움
    <br>
    4. 반복적 모델(Iteration Model)
        - 구축대상을 나누어 **병렬적으로 개발 후 통합** 하거나 **반복적으로 개발하여** 점증 완성시키는 모델
        - 사용자의 요구사항 일부분 or 제품 일부분을 반복적으로 개발하여 시스템을 최종으로 완성하는 모델
        - 관리 비용 ↑ , 일정 시간 ↓

### * 소프트웨어 개발방법론
- 정의 : 소프트웨어 개발 전 과정에서 지속적으로 적용할 수 있는 **방법, 절차, 기법이며 개발의 시작~시스템을 사용하지 않는 과정까지의 과정을 형상화 한 방법론**

- 종류 : <br>
    1. 구조적 방법론
        - 전체 시스템을 **기능에 따라 나누어 개발**하고 통합하는 방식
        - 프로세스 중심의 **하향식** 방법론
        - 나씨-슈나이더만 차트 사용 
        >> [나씨-슈나이더만] <br> - 논리 기술에 중점을 둔 도형식 표현 방법 <br> - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현 <br> 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
    <br>
    2. 정보공학 방법론
        - 정보시스템 개발에 필요한 **관리 절차와 작업 기법을 체계화**한 방법론 
        - 개발주기를 이용해 **대형 프로젝트를 수행**하는 체계적인 방법론
    <br>
    3. 객체지향 방법론 
        - *객체*라는 기본 단위로 시스템을 분석 및 설계하는 방법론
        - 사람이 이해하는 방식으로 시스템에 적용하는 방법론
        - **객체, 클래스, 메세지**를 사용
    <br>
    4. 컴포넌트 기반 방법론
        - 소프트웨어를 구성하는 **컴포넌트를 조립해서** 하나의 새로운 응용 프로그램을 작성하는 방법론
        - >>[컴포넌트] DB와 소프트웨어의 개발된 모듈 단위
        - 개발 기간 ↓, 생산성 ↑, 새로운 기능 추가 쉬움(확장성), 소프트에어 재사용 O
    <br>
    5. 제품 계열 방법론
        - 특정 제품에 적용고 싶은 **공통된 기능을 정의해 개발**하는 방법론
        - 임베디드 소프트웨어를 작성는데 유용한 방법론
    <br>
    6. **애자일 방법론(Agile)**
        - **절차보다는 사람 중심**이 되어 변화에 유연하고 효율적으로 시스템을 개발할 수 있는 방법론
        - **개발기간이 짧고 신속해** 폭포수 모형과 대비됨(개발과 함께 즉시 피드백을 받아 유동적으로 개발이 가능)
        - 유형 : XP, 린(Lean), 스크럼(SCRUM) <br>
            ① XP : 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론 
            - 1 ~ 3주 반복 개발주기
            - 5가지 가치와 12개의 실천항목이 존재
                <details><summary>5가지 가치</summary>
                    - 용기(Courage) : 용기를 가지고 자신감 있게 개발
                    <br>
                    - 단순성(Simplicity) : 필요한 것만 하고 그 이상의 것들은 하지 않음 
                    <br>
                    - 의사소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통
                    <br>
                    - 피드백(Feedback) : 의사소통에 대한 빠른 피드백
                    <br>
                    - 존중(Respect) : 팀원간의 상호 존중
                </details>
                <details><summary>12개의 실천 항목</summary>
                    - 짝 프로그래밍(Pair Programming) : 개발자 둘이서 짝으로 코딩
                    <br>
                    - 공동 코드 소유(Collective Ownership) : 누구든지 언제나 수정 가능
                    <br>
                    - 지속적인 통합(Continuous Intergration) : CI / 매일 여러번 소프트웨어를 통합하고 빌드
                    <br>
                    - 계획 세우기(Planning Process) : 고객이 요구하는 비즈니스 가치를 정의하고 개방자가 필요한게 무엇이며 어떤 부분에서 지연될수 있는지를 알려주어야한다는 원리
                    <br>
                    - 작은 릴리즈(Small Release) : 작은 시스템을 먼저 만들고 짧은 단위로 업데이트
                    <br>
                    - 메타포어(Metaphor) : 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자간의 의사소통을 원활하게 한다는 원리
                    <br>
                    - 간단한 디자인 : 현재의 요구사항에 적합한 가장 단순한 시스템을 설계
                    <br>
                    - 테스트 기반 개발(Test Driven Develop) : TDD / 프로그램 테스트를 먼저 수행 후 테스트 통과를 위해 실제 프로그램의 코드를 작성
                    <br>
                    - 리팩토링(Refactoring) : 프로그램의 기능을 바꾸지 않고 중복제거, 단순화등을 위해 시스템을 재구성함
                    <br>
                    - 40시간 작업 : 개발자의 컨디션을 위해 일주일에 40시간 이상 일하지 않게 한다는 원리
                    <br>
                    - 고객 상주 : 개발자들의 질의에 대해 답변을 해줄 고객이 프로젝트에 풀타임으로 상주
                    <br> 
                    - 코드 표준 : 모든 코딩에 대한 코딩 표준을 정의
                </details>
            ② 린 : 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용한 방법론으로 낭비 요소를 제거해 품질 향상을 시키는 방법론
            <br>
            ③ 스크럼 : 매일 정해진 시간과 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론
            - 백로그(Backlog) : 제품과 프로젝트에 대한 요구사항
            - 스프린트(Sprint) : 2~4주의 짧은 개발 기간동안 반복적 수행으로 개발품질 향상
            - 스크럼 미팅(Scrum Meetinn) : 매일 15분 정도 미팅으로 To-Do List 계획 수립, Daily Meeting
            - 스크럼 마스터(Scrum Master) : Project Leader
            - 스프린트 회고(Sprint Retrospective) : 스프린트 주기를 되돌아보면서 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록 / 해당 스프린트가 끝난 시점이나 일정 주기로 시행
            - 번 다운 차트 (Burn Down Chart) : 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트 
            <<<<그림넣기>>>>

## 1-2. 비용산정 & 일정관리 모형 ★★★
### * 비용산정 모형
- 정의 : 실행 가능한 계획을 수립하기 위해 비용을 산정하는 방식
- 분류 : <br>
    1. 하향식 : 전문가에게 비용산정을 의뢰 or 여러 전문가와 조정자를 통해 산정하는 방식
        >> 전문가 판단, 델파이기법
    2. 상향식 : 세부적인 요구사항과 기능에 따라 필요한 비용을 계산하는 방식
        >> 코드라인수(Loc), Man Month, COCOMO모형, 푸트남모형, 기능점수(FP)모형

        #### ① Loc(Lines Of Code)
        - 각 기능의 원시 코드 라인 수의 **낙관치, 중간치, 비관치를 측정**하여 비용을 산정
        ```
        예측치 = a + 4m + b / 6
        ----------------------------
        a = 낙관치(가장 적게 측정된 코드 라인 수)
        m = 중간치(측정된 모든 코드 라인 수의 평균)
        b = 비관치(가장 많이 측정된 코드 라인 수)
        ```
        #### ② Man Month 모형
        - **한 사람이 1개월 동안 할 수 있는 일의 양**을 기준으로 프로젝트 비용을 산정
        ```
        (Man Month) = (LoC)/(프로그래머의 월간 생산성)
        (프로젝트 기간) = (Man Month)/(프로젝트 인력)
        ```
        #### ③ COCOMO 모형
        - **보헴(Bohem)이 제안**한 모형으로 **프로그램 규모에 따라** 비용을 산정

        #### ④ 푸트남(Putnam) 모형
        - 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식
        - 생명주기 예측 모형, 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력분포도를 기초로함

        #### ⑤ 기능점수(Function Point) 모형
        - 요구 기능을 증가시키는 인자별로 가중치를 부여하고 요인별 가중치를 합산해 총 기능의 점수를 계산하여 비용을 산정
        - 경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치 부여
        ```
        기능점수(FP) = 총 기능점수 x [0.65 + (0.1 x 총 영향도)
        ``` 
### * 일정관리 모형
- 정의 : 프로젝트가 일정 기한 내에 적절하게 완료될 수 있도록 관리하는 모델
- 종류 :
    1. 주 공정법 (CPM; Critical Path Method)
        - 여러 작업의 수행 순서가 있는 프로젝트의 일정을 계산하는 기법
        - 모든 자원의 제약사항을 배제하고 프로젝트의 시작과 끝을 나타내는 노드간 연결을 통해 공정을 계산하기 위한 Activity 표기법
        - *예시 넣기*
    2. PERT (Program Evaluation and Review Technique)
        - 일의 순서는 계획적으로 정리하기 위한 수렴기법
        - 비관치, 중간치, 낙관치의 추정방식을 통해 일정을 관리하는 기법
    3. 중요 연쇄 프로젝트 관리(CCPM; Critical Chain Project Management) 
        - 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법111

## 2-1. 현행 시스템 분석
### * 현행 시스템 파악
- 정의 : 사용하고 있는 S/W 및 H/W가 무엇인지, 네트워크의 구성은 어떻게 되어있는지 파악하는 활동
- 절차 : 
// 그림
    구성/기능/인터페이스 파악 

### * 소프트웨어 아키텍처
- 정의 : 여러가지 S/W 구성요소와 외부에 드러나는 특성, 구성요소 간의 관계를 표현하는 시스템의 구조
- 4 + 1 뷰
    - 정리된 고객의 요구사항을 4개의 관점에서 바라보는 S/W적인 접근 방법
    >> [구성요소] 논리, 구현, 프로세스, 배포 + 유스케이스
    1. 논리 뷰 : 시스템의 기능적 요구사항 설명 
    2. 구현 뷰 : S/W 모듈의 구성을 보여줌
    3. 프로세스 뷰 :  자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 등을 처리
    4. 배포 뷰 : 컴포넌트다 물리적인 아키텍처에 어떻게 배치되는가를 매핑
    5. 유스케이스 뷰 : 다른 뷰를 검증하는데 사용

- 패턴 : S/W 설계 할 떄 참조할 수 있는 전형적인 해결 방식
    - >> [소프트웨어 아키텍처 패턴의 유형] 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴(MVC 패턴)
- 비용 평가 모델 : 아키텍처 접근법이 품질 속성에 미치는 영향을 판단라고 아키텍처의 적합성을 평가하는 모델
    - >> [종류] SAAM, ATAM, CBAM, ADR, ARID
    1. SAAM : 경험이 없는 조직에서도 활용 가능 , 변경용이성 & 기능성에 집중
    2. ATAM : SAAM을 계승해 발전, 품질 속성들의 이해상충관계 평가
    3. CBAM : ATAM에서 부족한 경제성 평가 보장
    4. ADR : 구성요소 간 **응집도** 평가
    5. ARID : **특정 부분에 대한** 비용 평가
### * 디자인 패턴
- 정의 : 공통으로 발생하는 문제에 대해 자주쓰이는 설계 방법을 정리한 패턴
    >> [구성요소] #패문솔 사결샘 <br>패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플코드
- 유형 : 
    - 목적 : 생성, 구조, 행위
        1. 생성 
            - Builder : 복잡한 인스턴스를 조립하여 만드는 구조
            - Prototype : 일반적인 원형을 만들고 복사해 필요한 부분만 수정하는 패턴
            - Factory Method : 상위, 하위클래스를 분리해 객체를 생성(오버라이딩)
            - Abstract Factory : 공통된 인터페이스를 제공
            - Singleton : 객체를 하나만 생성해 어디서든지 참조 가능
        2. 구조
            - Bridge : 기능의 클래스 계층과 구현의 클래스 계층을 연결 
            - Decorator : 구현되어 있는 클래스에 필요한 기능을 추가
            - Facade : 통합된 인터페이스 제공
            - Flyweight : 공통된 요소를 클래스화해 공유함, '클래스의 경량화'
            - Proxy : 실제 객체에 대한 대리 객체, 정보은닉의 역할 수행
            - Composite : 객체들의 관계를 트리구조로 구성 , 부분-전체 계층을 표현
            - Adaptor : 기존 클래스를 재사용하기 위한 인터페이스를 만드는 패턴
        3. 행위
            - Mediator : **중재자**를 통한 객체 지향 목표를 달성하게 해주는 패턴
            - Interpreter : 여러 형태의 언어 구문을 **해석**할 수 있게 만드는 패턴
            - Observer : **느슨하게 결합**, 한 객체의 상태가 변경이 되면 **자동으로 내용이 갱신**되는 방법
            - State : 객체 상태를 **캡슐화**하여 클래스화함으로써 참조하게 만드는 방법 
            - Visitor : 해당 클래스의 메소드가 각 클래스를 **돌아다니며** 특정 작업을 수행하도록하는 방법
            - Command : 실행될 기능을 캡슐화해서 **재사용성이 높은 클래스를 설계**하는 패턴
            - Strategy : **알고리즘을 각각 하나의 클래스로 캡슐화**해 필요할때마다 서로 교환해서 사용할 수 있게 해주는 패턴
            - Memento : **Undo**기능을 개발할 때 사용 (객체를 이전 상태로 되돌려야하는 경우)
            - Chain of Responsibility : 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 패턴, 한 요청을 2개 이상의 객체에서 처리
    - 범위 : 클래스 , 객체
## 2-2. 개발 기술 환경 정의
### * 운영체제(Operating System)
- 사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 S/W
- 운영체제 시스템 분석 시 고려사항 
    >> [품질 측면] 신뢰도, 성능 <br> 
    [지원 측면] 기술 지원, 주변 기기, 구축 비용
- 종류 : PC, 모바일로 나뉨 <br>
    |구분|종류|저작자|특징|
    |-----|------|---|---|
    |PC|윈도즈(Windows)|Microsoft|중&소규모, 일반 PC 등 유지, 관리 비용↓|
    ||유닉스(UNIX)|IBM, HP, SUN|대용량 처리, 안정성 높음|
    ||리눅스(Linux)|Linus Torvalds|중&대규모, 보안성 ↑|
    |모바일|안드로이드(Android)|Google|리눅스 운영채제에서 구동하며 핸드폰 전화를 포함한 휴대용장치를 위한 모바일 운영체제|
    ||iOS|Apple|스마트폰, 태블릿PC의 높은 보안성과 고성능 제공|

### * 네트워크 (Network)
- 컴퓨터 장치들의 노드 간 연결을 사용하여 데이터를 주고 받을 수 있도록 하는 기술 
- OSI 7계층 : 네트워크 통신에서 발생하는 문제 해결을 위해 **국제표준화기구(ISO)에서 제시한 네트워크 기본 모델**
    |계층|프로토콜|전송단위|설명|
    |-----|------|---|---|
    |응용 계층(Application Layer)|HTTP, FTP|데이터(Data)|사용자와 네트워크 간 응용서비스 연결, 데이터 생성|
    |표현 계층(Presentation Layer)|JPEG, MPEG|데이터(Data)|데이터 형식 설정, 암/복호화|
    |세션 계층(Session Layer)|SSH, TLS|데이터(Data)|연결 접속 및 동기제어|
    |전송 계층(Transport Layer)|TCP, UDP|세그먼트(Segment)|신뢰성있는 통신 보장, 데이터 분할과 재조립|
    |네트워크 계층(Network Layer)|IP, ICMP|패킷(Packet)|단말 간 데이터 전송을 위한 최적화된 경로 제공|
    |데이터링크 계층(Data Link Layer)|이더넷|프레임(Frame)|데이터 전송, 전송 오류 제어, 오류검출, 재전송 기능 제공, 동기화|
    |물리 계층(Physical Layer)|RS-232C|비트(Bit)|0과1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환|

### * DBMS (DataBase Management System)
- 데이터의 집합을 만들고 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
- 기능 :
    1. 중복 제어 : 동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지
    2. 접근 통제 : 권한에 따른 데이터에 대한 접근 제어 
    3. 인터페이스 제공 : 사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공
    >> CLI - 명령어를 텍스트로 입력하여 조작하는 사용자 인터페이스 <br>
    GUI - 그래픽 환경을 기반으로 마우스를 이용한 사용자 인터페이스
    4. 관계 표현
    5. 샤딩/파티셔닝 : 작은 단위로 나누는 기능
    6. 무결성 제약조건 
    7. 백업 및 회복 : 장애 발생 시 데이터 보존 기능
- DBMS 현행 시스템 분석시 고려사항
    - 성능 측면 : 가용성, 성능, 상호호환성
    - 지원 측면 : 기술 지원, 구축 비용

### * 미들웨어(Middleware)
- 응용프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어지게 제어해주는 S/W
- EX) WAS(웹어플리케이션서버)
- 미들웨어 현행 시스템 분석 시 고려사항
    - 성능 측면 : 가용성, 성능
    - 지원 측면 : 기술 지원, 구축 비용
 