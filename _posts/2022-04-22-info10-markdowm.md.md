---
layout: post
title: 10. 애플리케이션 테스트 관리
subtitle: ★★★ 
categories: markdown
tags: [정보처리기사_실기]
---

# 10. 애플리케이션 테스트 관리
## 10-1. 애플리케이션 테스트 케이스 설계
### * 애플리케이션 테스트 케이스 작성
1. ***소프트웨어 테스트***의 이해
    - 소프트웨어 테스트란 사용자의 요구사항에 만족하는지 확인하고 숨어있는 결함을 찾아내는 활동 
    - 소프트웨어 테스트의 **필요성** : (**발예향**)
        - 오류 **발견** 관점 
        - 오류 **예방** 관점
        - **품질 향상** 관점
    - 소프트웨어 테스트의 ***기본 원칙*** : (**결완초집 살정오** ; **결**정했어 **완**전 **초**가**집**에서 삼겹**살**을 **정오**에 구워먹을래 테스트해보자)
        - **결**함이 존재 : 결함이 존재함을 밝히는 활동 , 결함을 줄이는 활동
        - **완**벽한 테스팅 불가능 : 완벽하게 테스팅하려는 시도는 불필요한 시간과 자원낭비
        - **초**기에 테스팅 시작 : 초기에 체계적인 분석 및 설계 X → 후반에 영향을 미치게 비용이 ↑ (요르돈의 법칙 적용)
        - 결함 **집**중 : 적은 수의 모듈에서 대다수 결함이 발견됨 , **오류의 80%는 전체 모듈의 20%내에서 발견됨**(파레토 법칙)
        - **살**충제 패러독스 : **동일한 테스트 케이스에 의한 반복적 테스트 → 새로운 결함 발견 X** 
        - **정**황에 의존 : S/W 성격에 맞게 테스트 
        - **오**류-부재의 궤변 : 요구사항을 충족시키지 못한다면 결함이 없다고 해도 품질이 높다고 할 수 X 
    - 소프트웨어 테스트 ***프로세스***
        > 테스트 '계획' → 테스트 '분석 및 디자인' → 테스트 '케이스 및 시나리오 작성' → 테스트 '수행' → 테스트 '결과 평과 및 리포팅' 
    - 소프트웨어 테스트 ***산출물***
        |산출물|내용
        |-----|----
        |테스트 **계획서** | 테스트 수행을 계획한 문서  
        |테스트 **베이시스** | **논리적인 Case로** 테스트 설계를 위한 기준이 되는 문서
        |테스트 **케이스** | 테스트를 위한 **설계 산출물** , 테스트 항목의 명세서 
        |테스트 **슈트** | 테스트 케이스를 **실행 환경에 따라** 구분해 놓은 **테스트 케이스들의 집합** 
        |테스트 **시나리오** | 테스트 되어야 할 기능 및 특징, **테스트가 필요한 상황을 작성한 문서** / 하나의 테스트 시나리오가 여러개의 테스트 케이스들을 포함할 수 O
        |테스트 **스크립트** | 테이스 케이스의 **실행 순서**를 작성한 문서 = 테스트 스텝, 테스트 절차서
        |테스트 **결과서** | 테스트 **결과를 정리한** 문서 , 테스트 결과를 **평가하고 리포팅하는** 문서 
2. 소프트웨어 테스트 ***유형*** 
    - ***프로그램 실행여부***에 따른 분류 
        - **정적** 테스트 : 테스트 대상을 **실행하지 않고** 구조를 분석해 **논리성을 검증**하는 테스트 
            > [종류] 리뷰, 정적분석
            ```
            ① 리뷰 : 전문가가 수행 (人이 수행)
            - 유형 : 관리 리뷰(전반적인 검토) , 기술 리뷰 (명세 준수하는지 검토), 인스펙션(다른 전문가orㅌ 팀이 검사), 워크스루(짧은시간동안 회의를 진행하는 리뷰), 감사(독립적으로 평가, 제3기관이 수행)
            
            ▷ 과정 : 계획 수립 → 절차 밑 작업물의 개요 설명 → 준비 → 검토 회의 → 재작업 → 후속 작업
            ----------------------------------------------------------------------------------
            ② 정적분석 : 도구의 지원을 받아 정적테스트를 진행하는 방식 (도구 기반)
            - 유형: 코딩표준 부합, 코드 복잡도 계산, 자료 흐름 분석
            ```
        - **동적** 테스트 : 소프트웨어를 **실행하는 방식**으로 테스트를 수행해 **결함을 검출**하는 테스트 
            >[종류] 화이트 박스 테스트, 블랙박스 테스트, 경험기반 테스트
    - ***테스트 기법***에 따른 분류
        - **화이트 박스** 테스트(구조 기반) : 각 응용 프로그램 **내부 구조와 동작을 검사**하는 S/W 테스트
            > [유형] **구결조 조변다 기제데**

            ① **구문** = 문장 커버리지 (Statement Coverage) : 프로그램 내에 모든 **명령문을 적어도 한 번 수행**하는 커버러지 , 조건문 결과와 상관없이 구문 실행 갯수로 계산 <br> ② **결정** = 선택 (Decision) = 분기 (Branch) 커버리지 :  **전체 조건식**이 적어도 한번은 **참과 거짓의 결과를 수행**하는 테스트 커버리지 , '결정 커버리지 ⊃ 구문커버리지 ' <br> 
            > [테스트 커버리지?] 테스트수행의 완벽성을 측정하는 도구 <br> - 유형 : **기라코** / 기능 기반 , 라인, 코드 커버리지

            ③ **조건** 커버리지 (Codition) : 각 **개별 조건식**이 적어도 한번은 **참과 거짓의 결과를 수행**하는 테스트 커버리지 , '조건 커버리지 ⊃ 구문커버리지 ' <br> ④ **조건/결정** 커버리지 : **전체 조건식 + 개별 조건식 → 참 1번 , 거짓 1번 결과가 되도록 수행**하는 테스트 커버리지 <br> ⑤ **변경 조건/결정** 커버리지 (Modified Condition/Decision) : 개별 조건식이 **다른 조건식에 영향을 받지 않고 전체적인 조건식에 독립적으로** 영향을 주도록하는 테스트 커버리지 , 조건/결정 커버리지 향상시킨 커버리지 <br> ⑥ **다중 조건** 커버리지 (Muitiple Condition) : 모든 개별 조건식의 **가능한 모든 조합을 100%로 보장**하는 커버리지 <br> ⑦ **기본 경로** 커버리지 (Base Path) : **수행 가능한 모든 경로를 테스트**하는 기법 <br> 
            ```
            #맥케이브 계산식
            V(G) = E-N+2
            V(G) = P+1
            -----------------------------
            V(G) : 복잡도 
            E : 간선 수
            N : 노드 수
            P : 분기 수 
            ```     
            ⑧ **제어 흐름** 테스트 (Control Flow Testing) : 프로그램 제어 구조를 **그래프 형태로 나타내어 내부로직을 테스트**하는 기법 <br> ⑨ **데이터 흐름** 테스트 (Data Flow Testing) : 제어 흐름 그래프 + **데이터 사용 현황** 
        - **블랙박스** 테스트 (= 명세 테스트): 프로그램 **외부 사용자의 요구사항 명세를 보면서 수행**하는 테스트 
            >[유형] **동경결상 유분페원비**
            
            ① **동등분할** = 동치분할 = 균등 분할 = 동치 클래스 분해 테스트 (Equivalence Partitioning Testing) : 입력 데이터의 영역을 유사한 도메인별로 **유효값/무효값을 그룹핑해 대표값 테스트 케이스를 도출**하여 테스트 하는 기법 <br> ② **경곗값 분석** = 한곗값 테스트 (Boundary Value Analysis Testing) : **경곗값을 포함해 테스트 케이스를 설계**하여 테스트하는 기법 <br> ③ **결정 테이블** 테스트 (Decision Table) : 요구사항의 논리와 발생조건을 테이블 형태로 나열해 **조건과 행위를 모두 조합하여 테스트** 하는 기법 <br> ④ **상태 전이** 테스트 (State Transition) : 이벤트에 의해 **어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행**하는 테스트 기법 <br> ⑤ **유스케이스** 테스트 (Use Case) : **프로세스 흐름을 기반으로 테스트 케이스 명세화**해 수행하는 테스트 기법 <br> ⑥ **분류 트리** 케이스 (Classification Tree Method) : S/W 일부 or 전체를 **트리 구조로 분석 및 표현해** 테스트 케이스를 설계하여 테스트 <br> ⑦ **페어와이즈** 테스트 (Pairwise) : **데이터값 간에 최소한 한번씩은 조합하는 방식** <br> ⑧ **원인-결과 그래프** 테스트 (Causr-Effect Graphing) : 그래프를   입력 데이터 간 관계 및 **출력에 미치는 영향을 분석**하여 효용성이 높은 테스트 케이스를 선정하는 방식 <br> ⑨ **비교** 테스트 (Comparsion) : **여러 버전의 프로그램에 같은 입력값을 넣어 동일한 결과가 나오는지 비교**해보는 기법
        - ***테스트 시각***에 따른 분류 
            - 검증 (Verification) : S/W 개발 **과정**을 테스트 / 개발자&시험자의 시각
            - 확인 (Validation) : S/W 개발 **결과**를 테스트 / 사용자 시각
        - ***테스트 목적***에 따른 분류 : (**회안성 구회병**)
            - **회복** 테스트 : 일부로 실패를 유도 → 시스템의 정상적 복귀 여부를 테스트 
            - **안정** 테스트 : 소스 코드내의 보안적인 결함을 **미리 점검**하는 테스트
            - **성능** 테스트 : 사용자 요구에 시스템이 반응하는 속도등을 측정하는 테스트 
                > [유형] <br> ① 부하테스트 : 시스템의 부하를 계속 증가시키면서 시스템의 임계점을 찾는 테스트 <br> ② 스트레스 테스트 : 임계점 이상의 부하를 가해 비정상적인 상황에서의 처리를 테스트 <br> ③ 스파이크 테스트 : 짧은 시간에 사용자가 몰릴 때 시스템의 반응 측정 테스트 <br> ④ 내구성 테스트 : 오랜 시간 동안 시스템에 높은 부하을 가해 시스템 반응 테스트 
            - **구조** 테스트 : 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 
            - **회귀** 테스트 : 오류가 없는지 확인하는 반복 테스트 
            - **병행** 테스트 : 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 
        - ***테스트 종류***에 따른 분류 :(**명구경**)
            - **명세** 기반 테스트 (블랙박스 테스트) : 요구사항 명세서를 기반으로 테스트 케이스를 선정해 테스트하는 기법 
                > **동경결상 유분페원비**
            - **구조** 기반 테스트 (화이트박스 테스트) : 내부 논리 흐름에 따라 케이스를 작성하고 확인하는 기법 
                > **구결조 조변다 기제데** 
            - **경험** 기반 테스트 (블랙박스 테스트) : 유사 S/W나 유사 기술 평가에서 테스터의 경험을 토대로 한 직관과 기술 능력을 기반으로 수행하는 기법
                > 탐색적, 오류추정, 체크리스트, 특성테스트
                
                |유형|설명| 구성요소
                |----|---|---
                |**탐색적** 테스트| 문서를 작성하지 않고 경험에 바탕을 둬 탐색적으로 기능을 수행해보면서 테스트하는 기법 / 테스트 엔지니어의 '휴리스틱'한 능력 필요 <br> ``` [휴리스틱?] 경험에 기반해 문제를 해결, 학습, 발견해내는 방법 ```| 테스트 차터, 시간제한, 노트, 회고 <br>```[테스트차터?] 각 테스터 세션에 대해 명확한 임무를 설정해 놓은 명령지 ``` <br> ```[회고?] 탐색적 테스트 종료 후 테스트 수행과정과 경험을 팀원과 공유하는 보고 회의```
                |오류 추정| 개발자가 범할 수 있는 실수를 추정해 이에 따른 결함이 검출되도록 테스트 케이스를 설계하여 테스트하는 기법 |
                |체크리스트|테스트하고 평가해야 할 내용과 경험을 분류해 나열한 후 하나씩 확인하는 테스트 기법|
                |특성테스트| 품질특성을 염두에 두고 이를 근거로 경험적으로 테스트 케이스를 설계하고 테스트하는 기법 / **ISO/IEC 9126-2** <br> ```[품질특성?] 소프트웨어 제품의 품질에 관한 특성- 기신사효유이 ```
3. ***테스트 오라클***
    - 테스트의 결과가 참인지 거짓인지를 판단하기 위해 **사전에 정의된 참값을 입력해 비교하는 기법**
    - 테스트 오라클 **종류** : (**참샘휴일**; **참새** 오늘 **휴일**입니다) <br>
        ① **참** 오라클 : **모든 입력값**에 대해 기대하는 결과를 생성 → 발생된 오류를 모두 검출할 수 있는 오라클 <br> 
        ② **샘플링** 오라클 : **특정한 입력값**에 대해서만 기대하는 결과를 제공해 주는 오라클 <br>
        ③ **휴리스틱** 오라클 : **샘플링 오라클을 개선한 오라클** , 특정 입력값에 대해 올바른 결괄르 제공 → 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클 <br>
        ④ **일관성** 오라클 : **수행 전과 후의 결과값이 동일한지** 확인하는 오라클 
### * 애플리케이션 테스트 시나리오 작성
1. 테스트 ***레벨*** : 함께 편성되고 관리되는 **테스트 활동의 그룹**
    - 테스트 레벨 ***종류*** : **단통시인**
        - **단위** 테스트 : 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계 
            > 자료 구조, 실행 경로, 오류 처리, 인터페이스 테스트 
        - **통합** 테스트 : 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호작용을 검증하는 테스트 
            > 빅뱅, 샌드위치, 상향식, 하향식 테스트
        - **시스템** 테스트 : 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증
            > 기능&비기능 요구사항 테스트
        - **인수** 테스트 : 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 
            > 계약, 규정, 사용자, 운영상의 인수, 알바&베타 테스트 
2. 테스트 ***시나리오*** : 테스트 수행을 위한 **여러 테스트 케이스의 집합**
3. 테스트 ***환경구축*** : **실제 운영 시스템에서 정상적으로 작동되는지 테스트하기 위해** 실제 운영 시스템과 동일 or 유사한 사양의 H/W, S/W, Network 등의 **환경시설을 구축하는 활동**
## 10-2. 애플리케이션 통합 테스트
### * 애플리케이션 테스트 수행 
1. **단위 테스트** : 개별적인 모듈을 테스트 
    - Mock 객체 생성 프레임워크  
        |목 객체 유형|설명
        |----|---
        |더미객체 (Dummy)| 테스트할때 객체만 필요하고 해당 객체의 기능까지는 필요하지 않은 경우에 사용 
        |테스트 스텁 (Stub) | 더미 객체의 단순 기능에 특정 상태를 가정해 특정한 값을 리턴 or 메세지 출력
        |테스트 드라이버 (Driver) | 테스트 대상 하위모듈을 호출하고 파라미터 전달, 모듈 테스트 수행 후 결과를 도출 
        |테스트 스파이 (Spy) | 주로 테스트 대상 클래스와 협력하는 클래스로 가는 출력을 검증하는 데 사용
        |가짜 객체 (Fake) | 실제 협력 클래스의 기능을 대체해야 할 경우 사용
    - 단위테스트 ***원칙*** 
        - 테스트를 몇번을 실행해도 동일한 결과, 사람의 개입 X → 테스트 통과되었는지 알 수 있게 작성
2. **통합 테스트** : 각 모듈 간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 체계적인 테스트 기법
    - 비점증적인 방식 : 한꺼번에 테스트 **(빅뱅방식)**
    - 점증적인 방식 : 상향식 통합 / 하향식 통합 
        - ***하향식 통합*** (Too Down) : **아래방향(위→아래)으로** 제어의 경로를 따라 이동하면서 통합 및 테스트를 진행, *'깊이-우선'* or *'너비-우선'* 방식으로 통합
            > [깊이-우선] : 다음 분기(Branch)로 넘어가기 전 해당 분기를 완벽하게 탐색하는 방법 <br> [너비-우선] : 인접한 노드를 먼저 탐색하는 방법
        - ***상향식 통합*** (Bottom Up) : **위쪽방향으로(아래→위)으로** 제어의 경로를 따라 이동하명서 구축과 테스트를 진행
        - ***샌드위치 통합*** : **상향식 + 하향식**, 하위프로젝트가 있는 **큰 규모의 통합 테스트에서** 사용하는 방식
3. **테스트 자동화 도구** : 테스트 도구를 활용해 반복적인 테스트 작업을 스크립트 형태로 구현 
    - 유형 : **(정실성통)**
        - **정**적 분석 도구 (Static Analysis Tools) : 만들어진 애플리케이션을 실행하지 않고 분석하는 도구
        - 테스트 **실**행 도구 (Test Execution Tools) : 작성된 스크립트를 실행하고 각 스크립트마다 특정 데이터와 테스트 수행방법을 포함 <br>
            ① 데이터 주도 접근 방식 : 테스트 데이터를 스프레드시트에 저장 <br> 
            ② 키워드 주도 접근 방식 : 키워드와 테스트 데이터를 스프레드시트에 저장
        - **성**능 테스트 도구 (Performance Test Tools) : 가상의 사용자를 생성해 테스트를 수행함으로써 성능 목표를 달성했는지 확인하는 도구 
        - 테스트 **통**제 도구 (Test Control Tools) : 테스트 수행에 필요한 데이터와 도구를 관리하는 형상관리도구등 
4. **테스트 하네스** : 테스트를 지원하기 위한 코드와 데이터, 단위 or 모듈 테스트에 사용하기 위해 코드 개발자가 작성
    - 구성요소 : **(드 스슈케 스목)**
        - 테스트 **드**라이버  
        - 테스트 **스**텁 
        - 테스트 **슈**트 
        - 테스트 **케**이스 : 입려값, 실행조건, 기대 결과등의 집합
        - 테스트 **스**크립트 : 자동화된 테스트 실행 절차에 대한 명세
        - **목** 오브젝트 : 사용자의 행위를 조건부로 사전에 입력해두면 그 상황에 예정된 행위를 수행하는 객체 
- ***테스트 리포팅*** : **(정요품 결실)**
    |구분|설명
    |----|---
    |테스트 결과 **정**리| 모든 테스트 완료 → 테스트 계획, 테스트 케이스 설계, 단계별 테스트 시나리오, 테스트 결과까지 모두 포함된 문서 작성
    |테스트 **요**약 문서| S/W 품질 상태를 포함한 문서 작성
    |**품**질 상태| 테스트 성공률, 테스트 커버리지, 발생한 결함의 수와 결함의 중요도 등이 포함 
    |테스트 **결**과서| 결함과 관련한 상황을 중점적으로 기록
    |테스트 **실**행 절차 리뷰 및 평가| 단계별 테스트 종료 시 테스트 실행 절차를 리뷰하고 결과에 대한 평가를 수행, 결과에 따라 실행 절차를 최적화해 다음 테스트에 적용 
- ***결함 관리 프로세스*** : **(계기검수 재추최)**
    > 결함 관리 **계획** → 결함 **기록** → 결함 **검토** → 결함 **수정** → 결함 **재확인** → 결함 상태 **추적** 및 모니터링 활동 → **최종** 결함 분석 및 보고서 작성
## 10-3. 애플리케이션 성능 개선 
### * 애플리케이션 성능 분석 *
- 애플리케이션 ***성능 측정 지표*** : **(처응경자)**
    - **처**리량 (Throughput) : 주어진 시간에 처리할 수 있는 트랜잭션의 수 
    - **응**답 시간 (Response Time) : 사용자 입력이 끝난 후 애플리케이션의 응답 출력이 개시될때까지의 시간
    - **경**과 시간 (Turnaround Time) : 사용자가 요구를 입력한 시점부터 트랜잭션 처리 후 그 결과의 출력이 완료할때까지 걸리는 시간 
    - **자**원 사용률 (Resource Usage) : 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량
- 애플리케이션 ***성능 저하 요인*** : **(락페릭사커)**
    - 데이터베이스 락 (DB **Lock**) : 대량의 데이터 조회, 과도한 업데이트, 인덱스 생성시 발생하는 현상
    - 불필요한 데이터베이스 패치 (DB **Fetch**) : 실제 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우
    - 연결 누수 (Connection **Leak**) : JDBC 객체를 사용 후 종료하지 않을 경우
    - 부적절한 커넥션 풀 크기 (Connction Pool **Size**) : 너무 작거나 크게 설정한 경우 
    - 확정 (**Commit**) 관련 : 트랜잭션이 확정되지 않고 커넥션 풀에 반환 or 불필요한 확정이 자주 발생하는 경우
### * 애플리케이션의 성능 개선 
1. 베드 코드 (Bad Code) : 로직을 이해하기 어려운 코드로 작성된 코드
    - ***사례*** 
        - 외계인 코드 (Alien Code) : 아주 오래되거나 개발자 or 참고문서가 없어 유지보수 작업이 어려운 코드
        - 스파게티 코드 (Spagheti Code) : 소스 코드가 복잡하게 얽힌 코드
        - 알 수 없는 변수명 : 변수나 메서드에 대한 이름 정의를 알 수 없는 코드 
        - 로직 중복 : 동일한 처리 로직이 중복되게 작성된 코드 
    ---
    - ***유형*** : **(오문이결침)**
        - **오**염 문서 
        - **문**서 부족 
        - 의미 없는 **이**름 
        - 높은 **결**합도 
        - 아키텍처 **침**식
2. 클린 코드 (Clean Code) : 가독성이 높고 단순하며 의존성을 줄이고 중복을 최소화해 깔끔하게 잘 정리된 코드 
    - ***작성 원칙*** : **(가단의 중추)**
        - **가**시성 
        - **단**순성 
        - **의**존성 최소 
        - **중**복성 제거 
        - **추**상화 
    ---
    - ***유형***
        - 의미 있는 이름
        - 간결하고 명확한 주석
        - 보기 좋은 배치
        - 작은 함수 
        - 읽기 쉬운 제어 흐름
        - 오류 처리
        - 클래스 분할 배치 
        - 느슨한 결합 기법 적용
        - 코딩 형식 기법 적용 